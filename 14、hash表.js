/**
 * hash 表
 * 哈希表是一种非常重要的数据结构,
 * 原理
 * 哈希表通常通过数组实现的额,但是相对于数组,他有很多优势
 * 它可以提供非常快速的插入-删除-查找操作
 * 无论多少数据,插入和删除的需要接近常量的时间
 * 1.数组进行插入操作时,效率低
 * 2.数组进行的查找的操作的效率
 * 1)如果是基于索引进行查找操作,效率非常高
 * 2)基于内容去查找(比如name='why')
 * 3.数组进行删除,效率比较低
 * 优势
 * 无论多少数据,插入和删除需要接近常量的时间:即O(1)的时间级,实际上的,只需要几个机器指令即可完成
 * 哈希表比树还要快,基本上可可以瞬间查找到想要的元素
 * 哈希表相对于树来说的编码要容易很多
 * 不足
 * 哈希表中的数据是没有顺序的的.所以不能以一种固定的方式(比如从大到小),来遍历其中的元素
 * 通常情况下,哈希表中的key是不允许重复的,不能放置相同的key.用于爆粗一年不同的元素
 * hash 基于数组, 查找操作效率比较高
 * hash 表特殊特使就是利用特殊标识符进行对数据操作,特殊标识符对源数据的映射
 *
 * 
 */

// 5000个单词的存储
/**
 * 线性查找
 * 数据 -》 转换下标
 * 将字符串转的下标值
 * 
 */

// 将字符串转换成下标
/**
 * 字母转换成数字
 * 数字代替字符
 * ebcdic ibm 英文不是连续的
 * ascii 美国标准协会 将字母进行的了连续的的排列98-122
 * iso-8859-1 扩充
 * GBXXX -> GB2312 -> GBK -> GB18030 包括所有文字，并没有普及
 * Unicode 实现通用
 * cats 3 + 1 + 20 + 19 = 43 下标存储
 * 问题：按照这种方案的有个很明显的问题就是很多单词最终的下标可能都是43
 * 解决方案、
 * 幂的连成
 * c*27^3 + 1*27^2 +...幂的连成
 * 问题：如果一个单词是zzzzzz(一般英文单词不会超过)
 * 而且就算能创建这么大的数组，事实上有很多是无效的单词
 * 创建这么大的数组是没有意义的
 * hash 化概念
 * 将大数字转化成数组范围下标的过程，称之为哈希化
 * 哈希函数概念
 * 通常我们会单词转成数字，大数字在进行哈希化的代码实现放在函数中，这个函数称之为哈希函数
 * 哈希表概念
 * 最终将数据插入到这个数组，对整个数据的封装，称之为哈希表
 * 如何压缩，取余% 122%100 = 22 & 12%10 = 2
 * 哈希表冲突解决
 * 链地址法概念
 * 解决冲突重复，数组的位置放数组/链表，一旦发现重复，将重复的元素，放到链表的首部或者尾部，效率差不多
 * 线性查找（依次查找）
 * 开放址法概念
 * 寻找空白单元格，来添加重复的数据，三种解决方案
 * 1）线性探测
 * 插入的32 ，如果有元素，index+1，寻找空单元
 * 取元素，32, 不相等index+1，继续寻找，如果寻找到空停止查找，因为再插入过程中的会寻找空元素
 * 删除元素不可以将这个位置设置成null, 要用特殊符号表示 -1/*
 * 线性探测缺点
 * 一连串填充单元就叫聚集。
 * 聚集会影响哈希表性能
 * 2）二次探测
 * 探测步长优化，x+1^2，x+2^2 
 * 3）再哈希化
 * stepSize = constant - (key % consatant)
 * 5 - (key % 5)
 * 填装因子
 * 填装因子，表示当前哈希表中已经包含的数据项和整个哈希表的长度值
 * 装填因子 = 总数据项 / 哈希表长度， 5 / 10
 * 开放地址法的装在因子最大是多少呢？1 因为他必须寻找空白的单元才能将元素插入
 * 链地址法的装填因子呢，可以大于一，因为拉链法可以无限的延伸下去，只要你愿意，当然后面效率就变低了
 * 霍纳法则
 * n(n+1)/2
 */
